# numberBaseball
숫자야구 - 컴퓨터가 맞추기

user가 문제를 내고 컴퓨터가 맞추는 방법이다.
컴퓨터는 user가 설정한 숫자를 확인할 수 없다.
각각의 시도마다
"xx번째 시도 : 000
xBxS"
의 형태의 안내문 출력,
마지막에
"x번만에 맞히셨습니다.
게임을 종료합니다."
형태의 안내문 출력
컴퓨터의 사고력(?)을 증진시켜보자!

사람의 역할:
숫자 3개 입력 - hashSet과 배열 이용해서 저장, 배열은 정확한 숫자를 저장, hashSet은 나중에 중복검사 편하게 하기 위함

컴퓨터의 역할:
1. 3S가 나올때 까지 계속해서 반복
2. 숫자 3개 입력(Random), 하나 입력시 1~9 까지 저장 되어있는 List에서 하나씩 빼서 중복 방지 
3. 사람의 기억 역할하는 hashSet 이용해 중복되는 숫자인지 검사 -> 중복되면 attempt 늘리지 않고 다시 숫자 입력
4. 입력한 숫자들 판정해서 ball과 strike 수 저장
5. ball과 strike 합이 3일때 - 3S만들기에 집중, 반복문 따로 돌릴 것!
   - 3B
   - 숫자를 좌측 혹은 우측으로 한칸씩 밀어줌(ex: 123  -> 312 or 231)
   - 이 때 둘중 하나는 무조건 3S이므로 컴퓨터가 할일은 둘중하나 선택(Random)하는 것

   - 2B1S
   - 두 숫자 위치를 바꿔줌-> 그 결과 1/3 확률로 3S, 2/3 확률로 3B
   - 컴퓨터가 할 일은 (1,2), (2,3), (1,3) 중에 선택(Random)하는 것
  
   - 3S
   - 정답!
 6. ball과 strike 합이 0일때 - 어느 숫자도 포함 x 고로 List에 숫자 돌려주지 말고 continue
 7. 그 외- 아직 구현 x, ball과 strike의 합이 2인 경우에는 또 다른 사고과정을 설계하면 더 적은 시도로 답을 찾아낼 듯하다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------

2일차 의사코드
위 방법대로하면 ball + strike가 1, 2일때 너무 복잡해짐
사실 가장 확률이 높은 두 경우를 배제하면 효과적인 코드가 작성될 수 없음
아래와 같은 방법으로 다시 작성해보자

컴퓨터는 3자리 수 입력이 아닌 hash안에 있는 수 중에 하나 선택하는 것.
두가지 경우를 선택해야함, 두 경우는 생각해보면 다를게 없음.. 어짜피 유효한 숫자중 하나를 찍어야 함
1. 3개 따로 선택하는 것
2. 정해진 선택지 안에서 하나 선택하는 것
오히려 1번으로 하면 선택을 하고 그 선택을 다시 검사하는 이상한 상황이 발생해버림..
인간은 가능한 선택지를 계산하고 그 안에서 선택을 하므로 그와 가장 비슷한 2번 방법으로 코드를 다시 짜야함

준비 해야할 것:
1. realHash - 유효한 숫자를 저장해놓음
2. newHash - 새롭게 만들어진 유효한 숫자들, 반복문 한바퀴 돌 때마다 realHash에 모든 값 옮기고 비워짐.

코드 실행 과정:
1. realHash에 12~999 숫자를 저장한다. 이중 다른 자리의 숫자가 중복되는 수들은 제거하면# numberBaseball
숫자야구 - 컴퓨터가 맞추기

user가 문제를 내고 컴퓨터가 맞추는 방법이다.
컴퓨터는 user가 설정한 숫자를 확인할 수 없다.
각각의 시도마다
"xx번째 시도 : 000
xBxS"
의 형태의 안내문 출력,
마지막에
"x번만에 맞히셨습니다.
게임을 종료합니다."
형태의 안내문 출력
컴퓨터의 사고력(?)을 증진시켜보자!

사람의 역할:
숫자 3개 입력 - hashSet과 배열 이용해서 저장, 배열은 정확한 숫자를 저장, hashSet은 나중에 중복검사 편하게 하기 위함

컴퓨터의 역할:
1. 3S가 나올때 까지 계속해서 반복
2. 숫자 3개 입력(Random), 하나 입력시 1~9 까지 저장 되어있는 List에서 하나씩 빼서 중복 방지 
3. 사람의 기억 역할하는 hashSet 이용해 중복되는 숫자인지 검사 -> 중복되면 attempt 늘리지 않고 다시 숫자 입력
4. 입력한 숫자들 판정해서 ball과 strike 수 저장
5. ball과 strike 합이 3일때 - 3S만들기에 집중, 반복문 따로 돌릴 것!
   - 3B
   - 숫자를 좌측 혹은 우측으로 한칸씩 밀어줌(ex: 123  -> 312 or 231)
   - 이 때 둘중 하나는 무조건 3S이므로 컴퓨터가 할일은 둘중하나 선택(Random)하는 것

   - 2B1S
   - 두 숫자 위치를 바꿔줌-> 그 결과 1/3 확률로 3S, 2/3 확률로 3B
   - 컴퓨터가 할 일은 (1,2), (2,3), (1,3) 중에 선택(Random)하는 것
  
   - 3S
   - 정답!
 6. ball과 strike 합이 0일때 - 어느 숫자도 포함 x 고로 List에 숫자 돌려주지 말고 continue
 7. 그 외- 아직 구현 x, ball과 strike의 합이 2인 경우에는 또 다른 사고과정을 설계하면 더 적은 시도로 답을 찾아낼 듯하다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------

2일차 의사코드
위 방법대로하면 ball + strike가 1, 2일때 너무 복잡해짐
사실 가장 확률이 높은 두 경우를 배제하면 효과적인 코드가 작성될 수 없음
아래와 같은 방법으로 다시 작성해보자

컴퓨터는 3자리 수 입력이 아닌 hash안에 있는 수 중에 하나 선택하는 것.
두가지 경우를 선택해야함, 두 경우는 생각해보면 다를게 없음.. 어짜피 유효한 숫자중 하나를 찍어야 함
1. 3개 따로 선택하는 것
2. 정해진 선택지 안에서 하나 선택하는 것
오히려 1번으로 하면 선택을 하고 그 선택을 다시 검사하는 이상한 상황이 발생해버림..
인간은 가능한 선택지를 계산하고 그 안에서 선택을 하므로 그와 가장 비슷한 2번 방법으로 코드를 다시 짜야함

준비 해야할 것:
1. realHash - 유효한 숫자를 저장해놓음
2. newHash - 새롭게 만들어진 유효한 숫자들, 반복문 한바퀴 돌 때마다 realHash에 모든 값 옮기고 비워짐.

코드 실행 과정:
1. realHash에 12~999 숫자를 저장한다. 이중 다른 자리의 숫자가 중복되는 수들은 제거하면서 저장한다. 
2. while문으로 들어간다. 3S가 나오면 빠져 나오게끔 설계한다.
3. realHash의 크기만큼 reandom을 돌린다.
4. 뽑은 숫자를 자리수 별로 나눠 x, y, z에 저장한다.
5. 뽑은 숫자와 원하는 숫자를 대조해 ball, strike를 판별한다.
6. 나온 ball과 strike의 숫자가 아래와 같을때 각각 다른 조건을 설정해준다.
   - 0B0S : x,y,z 모두 배제시켜야 한다.
      fori {if (i in {x,y,z}) continue; }
        forj {if (j in {x,y,z}) continue; }
           fork {if (k in {x,y,z}) continue;
                 if (realHash.contain(ijk)) newHash.add(ijk) }
     realHash의 내용물을 newHash로 바꾸기, newHash비우기
   - 1B0S : 하나는 맞았으나, 같은 자리가 맞은게 아니고, x,y,z중 두개 이상이 포함될 수는 없다.
      fori {if (i == x) continue; }
        forj {if (j == y) continue; }
           fork {if (k == z) continue;
                 if (x,y,z가 동시에 두개 미만일때)
                    if (realHash.contain(ijk)) newHash.add(ijk) }
   - 0B1S : xjk, iyk, ijz중 하나의 경우, 0B0S와 비슷하게 이중 반복문으로 횟수를 낮춰 세번 반복하면 끝이다.
   - 1B1S : xzk, xjy, zyk, iyx, yjz, ixz 가 되는 경우만 골라주기
   - 2B : yxk, yjx, ixy, zjx, izx, zxk, zjy, izy, yzk 가 되는 경우만 골라주기
   - 2S : xyk, iyz, xjz 가 되는 경우만 골라주기
   - 2B1S : 두개 골라 위치 변환해서 저장하기 -> 3개 저장
   - 3B : 앞으로한칸 민거나 뒤로 한칸 민거 저장하기 -> 2개 저장
   - 3S : 종료!
7. 출력과 종료료
